###########################################
### Ecological networks                 ###
### for EcoservR tool                   ###
### Sandra Angers-Blondin               ###
### 12 May 2021                         ###
### Updated 01 May 2025 to terra        ###
###########################################

#' Ecological Networks
#'
#' Maps an ecological network to inform connectivity analysis. Six different habitat types can be mapped: woodlands, grasslands, heathlands, lowland wetlands, mires (bogs), and ponds. A generic focal species approach is used and the resulting network is therefore dependent on the habitat requirements (patch size) and dispersal ability of this hypothetical representative species.

#' @param x A basemap, in a list of sf tiles or as one sf object. Must have attribute HabCode_B.
#' @param studyArea The boundaries of the site, as one sf object. The final raster will be masked to this shape.
#' @param habitat The habitat for which to compute a network. Must be exactly one of the following: "woodland", "grassland", "heath", "pond", "mire", "wetland"
#' @param minsource The minimum patch size considered to be a viable habitat for the generic focal species, in hectares. Default is 0.1 ha (1000 square meters)
#' @param dispersal The dispersal distance (in meters) of generic focal species at three scales: core, meso and macro. Do not set the parameter if you wish to use the sensible defaults (see user guide), or specify as a vector of three numeric values, e.g. c(150, 1000, 1500)
#' @param threshold Functional size threshold (in hectares) under which a mapped network is considered too small to serve its purpose. Default is 0.5 ha.
#' @param use_hedges Use a separate hedgerow layer? Default FALSE, see clean_hedgerows() for producing a model-ready hedge layer.
#' @param custom_ext A custom extent; the extent of the final output will match this extent
#' @param res Desired resolution of the raster. Default is 10 m. Range recommended is 5-10m.
#' @param projectLog The RDS project log file generated by the wizard app and containing all file paths to data inputs and model parameters
#' @param runtitle A customised title you can give a specific model run, which will be appended to your project title in the outputs. If comparing a basemap to an intervention map, we recommend using "pre" and "post", or a short description of the interventions, e.g. "baseline" vs "tree planting".
#' @param save Path to folder where outputs will be saved. By default a folder will be created using your chosen run title, prefixed by "networks_". Do not use this argument unless you need to save the outputs somewhere else.
#' @param export_raster Logical. Save a raster version of the network as well as a polygon layer? Default TRUE.

#' @return A polygon identifying the core, meso, and macro networks with values of 1, 2, and 3 respectively. Note that the scales build on each other (e.g. meso network is the combination of all 1 and 2 values.)
#' @export
#'
hab_networks_scot <- function(x = parent.frame()$mm,
                              studyArea = parent.frame()$studyArea,
                              habitat, # the type of habitat (woodland, mire, wetland, heath, grassland, pond)
                              minsource = 0.1, # minimum patch size to be considered source (in ha). Default 0.1 ha (1000 square meters)
                              dispersal = NULL, # dispersal distance (m) for the generic focal species at the core, meso and macro scale. Leave NULL to use the default values, or use a vector of three numeric values.
                              threshold = 1, # minimum patch size (ha) to be considered a functional network
                              use_hedges = FALSE,
                              custom_ext = NULL,
                              res = 10, # resolution
                              projectLog = parent.frame()$projectLog,
                              runtitle = parent.frame()$runtitle,
                              export_raster = TRUE,
                              save = NULL) {
  # Create output directory automatically if doesn't already exist
  if (is.null(save)) {
    save <- file.path(
      projectLog$projpath,
      paste0("networks_", runtitle)
    )

    if (!dir.exists(save)) {
      dir.create(save)
    }
  } else {
    # if user specified their own save directory we check that it's ok
    if (!dir.exists(save) | file.access(save, 2) != 0) {
      stop("Save directory doesn't exist, or you don't have permission to write to it.")
    }
  }

  # Create a temp directory for scratch files

  scratch <- file.path(
    projectLog$projpath,
    "ecoservR_scratch"
  )

  if (!dir.exists(scratch)) {
    dir.create(scratch)
  }

  # if mm is stored in list, combine all before proceeding
  if (isTRUE(class(x) == "list")) {
    message("Recombining basemap tiles")
    x <- do.call(rbind, x) %>% sf::st_as_sf()
  }


  # Check that parameters are correctly specified

  if (!habitat %in% c("woodland", "grassland", "heath", "pond", "mire", "wetland")) {
    stop("Habitat must be one of: woodland, grassland, heath, wetland, mire, or pond")
  }

  if (!is.null(dispersal) & !(length(dispersal) == 3) & inherits(dispersal, "numeric")) {
    stop("Parameter \"dispersal\" must be a vector of 3 numeric values (in meters).
           Refer to user guide or do not set the parameter to use default values.")
  } else if (is.null(dispersal)) {
    dispersal <- if (habitat == "woodland") {
      c(150, 1000, 1500)
    } else if
    (habitat == "grassland") {
      c(150, 1000, 1500)
    } else if
    (habitat == "heath") {
      c(250, 1000, 1500)
    } else if
    (habitat == "pond") {
      c(50, 500, 1500)
    } else if
    (habitat == "mire") {
      c(150, 2000, 3000)
    } else if
    (habitat == "wetland") {
      c(150, 1000, 1500)
    }
  }


  # Identify which lookup column is relevant
  costcol <- if (habitat == "woodland") {
    "CostWood"
  } else if
  (habitat == "grassland") {
    "CostGrass"
  } else if
  (habitat == "heath") {
    "CostHeath"
  } else if
  (habitat == "pond") {
    "CostPond"
  } else if
  (habitat == "mire") {
    "CostMire"
  } else if
  (habitat == "wetland") {
    "CostLWet"
  }

  studyArea <- sf::st_zm(studyArea, drop = TRUE) # make sure study area doesn't have Z dim

  x <- checkcrs(x, 27700)
  studyArea <- checkcrs(studyArea, 27700)

  ### Check and import hedgerows ---
  if (use_hedges) {
    if (!file.exists(projectLog$clean_hedges)) {
      stop("use_hedges is TRUE but no file found. Check projectLog$clean_hedges")
    }

    hedges <- readRDS(projectLog$clean_hedges) %>%
      dplyr::mutate(HabCode_B = "J21") %>%
      merge(hab_lookup[c("Ph1code", costcol)], by.x = "HabCode_B", by.y = "Ph1code", all.x = TRUE)

    message("Loaded hedges from ", projectLog$clean_hedges)
    hedges <- checkcrs(hedges, 27700)
  }


  # Join costs to the basemap keeping only relevant attributes for faster processing
  x <- dplyr::left_join(x[, c("HabCode_B")],
    hab_lookup[, c("Ph1code", "HabBroad", costcol)], # join the relevant column
    by = c("HabCode_B" = "Ph1code")
  )


  # # Check geometry of mm as needs to be clean for rasterizing
  # x <- ecoservR::checkgeometry(x, "POLYGON")

  # Create raster template for all rasters
  r <- terra::rast(
    resolution = res,
    crs = sf::st_crs(x),
    extent = if (is.null(custom_ext)) terra::ext(x) else custom_ext
    # normally use extent of basemap to set raster ext
    # but optionally can pass an extent to ensure alignment
  )

  terra::origin(r) <- c(0, 0)


  message("Identifying source habitats for ", habitat)

  # Identify patches of source habitat

  if (habitat == "pond") {
    source <- x
  } else {
    source <- x[x[[costcol]] == 1, ]
  }

  ## Refine further, as cost of 1 is not necessarily the target habitat

  #### TO DO: CONDITIONAL FILTERING BY HABITAT HERE; ESP FOR POND, MIRE AND LWET

  if (habitat == "woodland") {
    source <- dplyr::filter(source, HabBroad %in% c("Woodland, broadleaved", "Woodland, mixed") &
      !HabCode_B %in% c("A112", "A112/A2", "A132", "A132/A2"))
  } else if (habitat == "grassland") {
    source <- dplyr::filter(source, HabBroad %in% c("Grassland, semi-natural", "Maritime cliff and slope", "Grassland, semi-improved"))
  } else if (habitat == "heath") {
    source <- dplyr::filter(source, HabBroad %in% c("Heathland"))
  } else if (habitat == "pond") {
    ## Calculate shp_area and shp_index

    source <- source %>%
      dplyr::mutate(
        shp_area = as.numeric(sf::st_area(.)),
        shp_length = as.numeric(sf::st_perimeter(.))
      ) %>%
      dplyr::mutate( # calculate shape index
        shp_index = (pi * ((shp_length / (2 * pi))^2)) / shp_area
      )

    source <- dplyr::filter(source, HabBroad %in% c("Water, fresh"), shp_area < 10000, shp_index <= 5)
  } else if (habitat == "mire") {
    source <- dplyr::filter(source, HabBroad %in% c("Grassland, marshy", "Mire", "Swamp", "Saltmarsh"))
  } else if (habitat == "wetland") {
    source <- dplyr::filter(source, HabBroad %in% c("Grassland, marshy"))
  }



  # Check geometry as needs to be clean for rasterizing

  if (sf::st_geometry_type(source, by_geometry = FALSE) != "POLYGON") {
    source <- source %>%
      sf::st_cast("MULTIPOLYGON", warn = FALSE) %>%
      sf::st_cast("POLYGON", warn = FALSE)
  }

  if (nrow(source) == 0) {
    message(paste0("No ", habitat, " habitat in your study area."))
    return() # exit function without crashing
  }

  # Need to union adjacent patches to calculate area correctly, but unioning a lot of polygons is a serious bottleneck. Instead we rasterize to identify patches, and then polygonize them.

  source_r <- fasterize::fasterize(source, raster::raster(r))
  source_r <- terra::rast(source_r)

  ## The terra approach is faster, but still the patches function can be slow, so we filter out small islands (clumps of 1-2 pixels) before starting, which is very fast and reduces number of patches to compute. We do this using focal;

  # Focal filter: sum the number of non-na cells within a 3x3 grid around pixel. All cells will score 1 for themselves, we keep those that have at least 2 neighbours (score 3)
  r_filtered <- terra::focal(source_r, w = matrix(1, 3, 3), fun = sum, na.rm = TRUE, na.policy = "omit", fillvalue = NA)
  rcl_mat <- matrix(c(
    0, 3, NA,
    3, Inf, 1
  ), ncol = 3, byrow = TRUE)
  r_filtered <- terra::classify(r_filtered, rcl_mat, right = NA)
  rm(source_r)

  message("Computing habitat patches")
  # Now compute patches
  patches <- terra::patches(r_filtered, direction = 8)

  # remove patches smaller than threshold
  # freq returns number of cells per patch, we can just convert to area (in ha)
  keep <- terra::freq(patches)
  keep$area_ha <- keep$count * res^2 / 10000
  keep <- keep[keep$area_ha >= minsource, ] # filter to patches we want to keep

  # We may have no habitat left after filtering
  if (nrow(keep) == 0 | all(is.na(keep))) {
    message(paste0("No ", habitat, " habitat patch greater than ", minsource, "ha in your study area."))
    return() # exit function without crashing
  }

  #source_r <- terra::ifel(patches %in% keep$value, 0, NA) # reclassify based on keeping/dropping
  source_r <- terra::ifel(terra::match(patches, keep$value) > 0, 0, NA)


  message("Creating cost raster for ", habitat)
  # Create resistance raster
  cost_r <- fasterize::fasterize(x, raster::raster(r), field = costcol) %>% terra::rast()

  ### Cost distance analysis -----
  message("Calculating cost distance")

  ## cover the cost raster with the source habs
  cost_r <- terra::mask(cost_r, source_r, inverse = TRUE) %>% # cover ONLY updates NA values, so we need to first remove the source locations from the cost raster
    terra::cover(source_r) # then add the 0 values

  # set the CRS so costdist knows the units
  terra::set.crs(cost_r, sf::st_crs(studyArea)$wkt)

  costdist <- terra::costDist(cost_r, target = 0) # do the cost-distance

  ## Reclassify raster to identify core (1), meso (2) and macro (3) networks based on dispersal distances

  costdist <- terra::classify(costdist,
    matrix(c(
      0, dispersal[[1]], 1, # core network
      dispersal[[1]], dispersal[[2]], 2, # meso network
      dispersal[[2]], dispersal[[3]], 3, # macro network
      dispersal[[3]], Inf, NA
    ), ncol = 3, byrow = TRUE),
    include.lowest = TRUE
  )

  # reset the crs as lost, yet again
  terra::set.crs(costdist, sf::st_crs(studyArea)$wkt)

  #costdist <- terra::crop(costdist, studyArea) %>% terra::mask(studyArea)

  terra::set.crs(costdist, sf::st_crs(studyArea)$wkt) # try to get CRS back

  # Polygonize the networks, so we can filter out the patches that are too small to be functional

  message("Creating network polygons...")

  core <- sf::st_as_sf(
    stars::st_as_stars(
      terra::classify(costdist,
        matrix(c(
          0, 1, 1,
          1, Inf, NA
        ), ncol = 3, byrow = TRUE),
        include.lowest = TRUE
      )
    ),
    as_points = FALSE,
    merge = TRUE
  ) %>%
    dplyr::mutate(
      area_ha = as.numeric(sf::st_area(.)) / 10000, # calculate area of networks
      type = 1
    ) %>% # give value
    dplyr::filter(area_ha > threshold) # remove those smaller than functional threshold

  meso <- sf::st_as_sf(
    stars::st_as_stars(
      terra::classify(costdist,
        matrix(c(
          0, 2, 1,
          2, Inf, NA
        ), ncol = 3, byrow = TRUE),
        include.lowest = TRUE
      )
    ),
    as_points = FALSE,
    merge = TRUE
  ) %>%
    dplyr::mutate(
      area_ha = as.numeric(sf::st_area(.)) / 10000,
      type = 2
    ) %>% # calculate area of networks
    dplyr::filter(area_ha > threshold) # remove those smaller than functional threshold

  macro <- sf::st_as_sf(
    stars::st_as_stars(
      terra::classify(costdist,
        matrix(c(
          0, 3, 1,
          3, Inf, NA
        ), ncol = 3, byrow = TRUE),
        include.lowest = TRUE
      )
    ),
    as_points = FALSE,
    merge = TRUE
  ) %>%
    dplyr::mutate(
      area_ha = as.numeric(sf::st_area(.)) / 10000,
      type = 3
    ) %>% # calculate area of networks
    dplyr::filter(area_ha > threshold) # remove those smaller than functional threshold


  network_poly <- rbind(core, macro, meso)
  rm(core, macro, meso)

  if (nrow(network_poly) > 0) {
    ## Recreate the rasters based on filtered polys
    network <- fasterize::fasterize(network_poly, raster::raster(r), field = "type", fun = "min") # prioritise core, then meso, then macro
    network <- terra::rast(network)
    terra::set.crs(network, sf::st_crs(studyArea)$wkt)


    ## get the final crop right
    #network <- terra::crop(network, studyArea) %>% terra::mask(studyArea)

    ## Save raster
    message("Saving your ", habitat, " ecological network.")
    terra::writeRaster(
      network,
      filename = file.path(
        save,
        paste0(projectLog$title, "_", runtitle, "_network_", habitat, ".tif")
      ),
      overwrite = TRUE # perhaps not desirable but for now prevents error messages
    )
  } else {
    message("No networks larger than functional threshold (", threshold, " ha) in your study area")
  }
}
