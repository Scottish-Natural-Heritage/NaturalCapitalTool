############################################################
### Revised pollination capacity - in development        ###
### NatureScot - Pollination sprint                      ###
### Sandra Angers-Blondin                                ###
### 09-09-2024                                           ###
###                                                      ###
### CSJ Update 31 Jan 2024                               ###
############################################################


#' Pollination Capacity Model
#'
#' Likelihood of visitation by wild pollinators. This model is driven by the presence of source habitat for pollinators and the permeability of the surrounding landscape. A cost-distance analysis maps the area within which pollinators are assumed to be able to disperse; this is inversely scored and a likelihood is calculated as per Schlup et al. 2014.
#'
#' @param x A basemap, in a list of sf tiles or as one sf object. Must have attribute HabCode_B.
#' @param studyArea The boundaries of the site, as one sf object. The final raster will be masked to this shape. For best results this shape should be smaller than the basemap (which should be buffered by typically 300 m - 1km to avoid edge effects).
#' @param res Desired resolution of the raster. Default is 10m. Range recommended is 5-10m.
#' @param edgedist Distance within which pollinators are found in edge habitats (woodland) from a core habitat. Default 20 m.
#' @param size_threshold Minimum area requirement for a patch to be considered a habitat source. Default 0.5 ha.
#' @param maxdist Maximum travel distance (m) for a pollinator. Default 2214m (previously 668 m).
#' @param custom_ext A custom extent; the extent of the final output will match this extent
#' @param use_hedges Use a separate hedgerow layer? Default FALSE, see clean_hedgerows() for producing a model-ready hedge layer.
#' @param projectLog The RDS project log file generated by the wizard app and containing all file paths to data inputs and model parameters
#' @param runtitle A customised title you can give a specific model run, which will be appended to your project title in the outputs. If comparing a basemap to an intervention map, we recommend using "pre" and "post", or a short description of the interventions, e.g. "baseline" vs "tree planting".
#' @param save Path to folder where outputs will be saved. By default a folder will be created using your chosen run title, prefixed by "services_". Do not use this argument unless you need to save the outputs somewhere else.
#' @return A raster with raw capacity scores (0-1: likelihood that a pollinator will visit a pixel).
#' @export
#'
capacity_pollination_scot <- function(
                                 x = parent.frame()$mm,
                                 studyArea = parent.frame()$studyArea,
                                 res = 10,
                                 edgedist = 20,
                                 size_threshold = 0.5, # minimum patch size (hectares)
                                 maxdist = 2214, # maximum dispersal distance (m) of a pollinator
                                 custom_ext = NULL,
                                 use_hedges = FALSE,
                                 projectLog = parent.frame()$projectLog,
                                 runtitle = parent.frame()$runtitle,
                                 save = NULL
){


   ### Imports and checks -----

   timeA <- Sys.time() # start time

   # Create output directory automatically if doesn't already exist
   if (is.null(save)){
      save <- file.path(projectLog$projpath,
                        paste0("services_", runtitle))
      if (!dir.exists(save)){dir.create(save)}
   } else {
      # if user specified their own save directory we check that it's ok
      if(!dir.exists(save) | file.access(save, 2) != 0){
         stop("Save directory doesn't exist, or you don't have permission to write to it.")}
   }

   # Create a temp directory for scratch files
   scratch <- file.path(projectLog$projpath,
                        "ecoservR_scratch")

   if(!dir.exists(scratch)){dir.create(scratch)}

   # if mm is stored in list, combine all before proceeding
   if (isTRUE(class(x) == "list")){
      message("Recombining basemap tiles")
      x <- do.call(rbind, x) %>% sf::st_as_sf()
      # NOT using rbindlist here because only keeps the extent of the first tile
   }
   # only retain what we need
   x <- x %>%
      dplyr::select(HabCode_B) ## maybe elevation if we work it back in
   
   studyArea <- sf::st_zm(studyArea, drop = TRUE) # make sure study area doesn't have Z dim
     


   ### Check and import hedgerows (not used currently) ----
   if (use_hedges){

      if (!file.exists(projectLog$clean_hedges)){stop("use_hedges is TRUE but no file found. Check", projectLog$clean_hedges)}

      hedges <- readRDS(projectLog$clean_hedges) %>%
         dplyr::mutate(HabCode_B = 'J21') %>% dplyr::select(HabCode_B) %>%
         merge(hab_lookup[c("Ph1code",'HabBroad', 'HabClass')], by.x = 'HabCode_B', by.y = 'Ph1code', all.x = TRUE)

      message("Loaded hedges from ", projectLog$clean_hedges)
      hedges <- rename_geometry(hedges, attr(x, "sf_column"))
   }


   ### Merge the lookup values we need -----

   # Ideally the CostPoll column will be coded with 0 for source habitat and costs of 1-50 for other habitats

   x <- merge(x, hab_lookup[c("Ph1code", "CostPoll")], 
              by.x = "HabCode_B", by.y = "Ph1code", all.x = TRUE) 

   ## Habitat definitions

   
   corehabs <- hab_lookup[hab_lookup$CostPoll == 0,] #core pollinator habitats defined as having cost of 0. This includes EUNIS 'E'

   edgehabs <- c("Woodland, coniferous",
                 "Woodland, broadleaved",
                 "Woodland, mixed")    # selection of woodlands as edge habitats

   ### Create raster template with same properties as mastermap -----
  # r <- terra::rast(resolution = res,
   #                 crs = "EPSG:27700",
  #                  extent = terra::ext(x))  # create empty raster
   # r <- raster::raster() # create empty raster
   #  raster::crs(r) <- sp::CRS(SRS_string = "EPSG:27700") # hard-coding datum to preserve CRS
   # raster::extent(r) <- raster::extent(x) # set same extent as the shapefile
   #raster::res(r) <- res # set resolution
   
   r <- raster::raster()  # create empty raster
   raster::crs(r) <- sp::CRS(SRS_string = "EPSG:27700") # hard-coding the datum to preserve CRS in QGIS
   
   if (is.null(custom_ext)) {
     raster::extent(r)  <- raster::extent(x)
   }else {
     raster::extent(r) <- raster::extent(custom_ext)
   }
   
   raster::res(r) <- res  # set resolution
   

   ### Create core habitat layer -----
   message("Creating layer of core habitats")

   core <- dplyr::filter(x, HabCode_B %in% corehabs)
   # %>%
   #    terra::vect() # convert to a terra vector type as faster than sf for next steps

   ## TODO add error handling here: what if there is no core habitat in area?

   # Create buffer around core with distance specified; we'll look for edge habitats in there
   # dissolve for simplicity
   corebuffer <- sf::st_buffer(core, edgedist) %>% sf::st_union()


   # if (use_hedges){  
   #    # add hedgerows to the corebuffer object
   #    hedges <- sf::st_buffer(hedges, edgedist) %>%
   #       sf::st_make_valid() %>% sf::st_geometry() %>% sf::st_as_sf() %>%
   #       sf::st_cast("MULTIPOLYGON") %>% sf::st_cast("POLYGON")
   #
   #    hedges <- rename_geometry(hedges, attr(corebuffer, "sf_column"))
   #    hedges <- checkcrs(hedges, 27700)
   #    corebuffer <- rbind(corebuffer, hedges)
   # }



   ### Create edge habitat layer -----
   message("Creating layer of edge habitats")

   edge <- dplyr::filter(x, grepl("A1", HabCode_B))

   # use buffer around core habitats to clip edge habitats used by pollinators
   edgeclip <- edge[unique(unlist(sf::st_intersects(corebuffer, edge))),] %>%
      sf::st_intersection(corebuffer) %>%
      sf::st_make_valid()  %>%
      st_collection_extract("POLYGON")
                                       
  

   ### Recombine and define habitat patches -----
   pollin_hab <- c(sf::st_geometry(edgeclip), sf::st_geometry(core)) %>%
     sf::st_union() %>% sf::st_as_sf() %>%
     sf::st_cast("MULTIPOLYGON") %>% sf::st_cast("POLYGON") %>% # explode back to single-part polys to filter out small ones
     mutate(area_ha = as.numeric(st_area(.))/10000) %>%
     filter(area_ha > size_threshold) 

   ### Create the source raster (pollinator habitats)
   pollin_r <- fasterize::fasterize(
      pollin_hab, # combining edge and core habs
      raster::raster(r) # empty raster, need converting to raster package for fasterize
      ) %>%
      terra::rast() %>%
      terra::classify(cbind(1, 0)) #%>%  # set value of patches to 0
     #terra::classify(cbind(NA, 9999))


   ### Cost distance analysis -----
   message("Calculating cost distance")

   cost_r <- fasterize::fasterize(
      x,
      raster::raster(r), # empty raster, need converting to raster package for fasterize
      field = "CostPoll"
   ) %>% terra::rast()

   ## cover the cost raster with the source habs
   cost_r <- terra::mask(cost_r, pollin_r, inverse=TRUE) %>% # cover ONLY updates NA values, so we need to first remove the source locations from the cost raster
      terra::cover(pollin_r)  # then add the 0 values

   costdist_r <- terra::costDist(cost_r, maxiter=600, target = 0, overwrite=TRUE) # do the cost-distance

   costdist_clamped <- terra::clamp(costdist_r, upper = maxdist, value = FALSE)


   message("Calculating likelihood of pollinator visit...")

   ### Calculate likelihoods -----
   pollin_r <- terra::writeRaster(
      exp(costdist_clamped*(-0.00104)),
      filename = file.path(scratch, "pollin_score.tif"),
      overwrite = TRUE  # because it's a temporary file we don't mind overwriting it if it exists
   )

   pollin_r <- terra::classify(pollin_r, cbind(NA, 0))  # replace NA with 0


   ### Clip to study area and save to outputs folder -----

   message("Saving final and standardised scores.")

   final <- terra::writeRaster(
      terra::mask(pollin_r, studyArea),
      filename = file.path(save, paste(projectLog$title, runtitle, "pollination_capacity.tif", sep="_")),
      overwrite = TRUE  # perhaps not desirable but for now prevents error messages
   )

   timeB <- Sys.time() # stop time

   # write performance to log
   projectLog$performance[["cap_pollin"]] <- as.numeric(difftime(
      timeB, timeA, units="mins"
   ))


   updateProjectLog(projectLog) # save revised log

   # Delete all the stuff we don't need anymore

   on.exit({
      rm(r, pollin_r, maxval)
      cleanUp(scratch)
      message("Pollination capacity model finished. Process took ", round(difftime(timeB, timeA, units = "mins"), digits = 1), " minutes. Please check output folder for your maps.")
   })

   return({
      ## returns the objects in the global environment
      invisible({
         projectLog <<- projectLog
      })
   })


}
