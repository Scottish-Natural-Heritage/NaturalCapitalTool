############################################################
### Revised pollination demand - in development          ###
### NatureScot - Pollination sprint                      ###
### Sandra Angers-Blondin                                ###
### 12-09-2024                                           ###
###                                                      ###
### CSJ Update 31 Jan 2024                               ###
############################################################

#' Pollination Demand Model
#'
#' Runs the pollination ecosystem service model, generating demand scores based on the distance to areas assumed to require insect pollination (crops, gardens, allotments). Habitats requiring pollination get the highest score (0), and other habitats are scored based on cost-distance values taken from SNH Research Report No. 887. This helps identify opportunities for creating habitats within a reasonable travel distance for a pollinator.

#' @param x A basemap, in a list of sf tiles or as one sf object. Must have attribute HabCode_B.
#' @param studyArea The boundaries of the site, as one sf object. The final raster will be masked to this shape. For best results this shape should be smaller than the basemap (which should be buffered by typically 300 m - 1km to avoid edge effects).
#' @param res Desired resolution of the raster. Default is 5 m. Range recommended is 5-10m.
#' @param dist Distance threshold from habitats requiring pollination. Default 2214m (previously 668 m).
#' @param size_threshold Minimum area requirement for a patch to be considered as having demand for the service. Default 0.5 ha.
#' @param custom_ext A custom extent; the extent of the final output will match this extent
#' @param projectLog The RDS project log file generated by the wizard app and containing all file paths to data inputs and model parameters
#' @param runtitle A customised title you can give a specific model run, which will be appended to your project title in the outputs. If comparing a basemap to an intervention map, we recommend using "pre" and "post", or a short description of the interventions, e.g. "baseline" vs "tree planting".
#' @param save Path to folder where outputs will be saved. By default a folder will be created using your chosen run title, prefixed by "services_". Do not use this argument unless you need to save the outputs somewhere else.
#' @return A raster with raw demand scores (0-1: likelihood that a pollinator will visit a pixel).
#' @export


demand_pollination_scot <- function(x = parent.frame()$mm,
                                       studyArea = parent.frame()$studyArea,
                                       res = 10,
                                       dist = 2214,
                                       size_threshold = 0.5,
                                       custom_ext = NULL,
                                       projectLog = parent.frame()$projectLog,
                                       runtitle = parent.frame()$runtitle,
                                       save = NULL
){

timeA <- Sys.time() # start time

# Create output directory automatically if doesn't already exist
if (is.null(save)){
  
  save <- file.path(projectLog$projpath,
                    paste0("services_", runtitle))
  
  if (!dir.exists(save)){
    dir.create(save)
  }
} else {
  # if user specified their own save directory we check that it's ok
  if(!dir.exists(save) | file.access(save, 2) != 0){
    stop("Save directory doesn't exist, or you don't have permission to write to it.")}
}

# Create a temp directory for scratch files

scratch <- file.path(projectLog$projpath,
                     "ecoservR_scratch")

if(!dir.exists(scratch)){
  dir.create(scratch)
}


# if mm is stored in list, combine all before proceeding
if (isTRUE(class(x) == "list")){
  message("Recombining basemap tiles")
  x <- do.call(rbind, x) %>% sf::st_as_sf()
}

# drop attributes we don't need and join HabBroad
x <- x %>% dplyr::select(HabCode_B, corine, LCscot, nfi)
x <- dplyr::left_join(x, hab_lookup[c("Ph1code", "HabBroad", "CostPoll")], 
                      by = c("HabCode_B" = "Ph1code"))


### Create raster template with same properties as mastermap -----
#r <- terra::rast(crs = "epsg:27700",
#                extent = terra::ext(x),
#                resolution=res) 

r <- raster::raster()  # create empty raster
raster::crs(r) <- sp::CRS(SRS_string = "EPSG:27700") # hard-coding the datum to preserve CRS in GIS

if (is.null(custom_ext)) {
  raster::extent(r)  <- raster::extent(x)
}else {
  raster::extent(r) <- raster::extent(custom_ext)
}

raster::res(r) <- res  # set resolution


### Create core habitat layer -----
message("Creating layer of land requiring pollination")

# list of habitats that require pollinators: arable, gardens, orchards
corehabs <- c(dplyr::filter(hab_lookup,
                            grepl("J11", Ph1code) |
                              HabBroad == "Gardens / Parks / Brownfield")$Ph1code,
              "A11-O", "A112o_T", "A112o")

### Filter to core habitats
message("Filter to core habitats")

x <- x %>%
  mutate(CostPoll = replace(CostPoll, CostPoll == 0, 0.000000000000000000001))#set all capacity source habs to 0.000...1,  Default 0 in CostPoll. This should mean that the cost distance paths essentially don't face friction in capacity source habitats, while still not being the target of the costDist. A check was performed, and the effect as expected was visible but not dramatically different.

core <- dplyr::filter(x, HabCode_B %in% corehabs) #Create subset of demand habitats (core)

corine_list <- c("Agro-forestry areas",             # create list of corine themes we want to keep
                 "Annual crops associated with permanent crops",
                 "Complex cultivation patterns",
                 "Fruit trees and berry plantations",
                 "Green urban areas",
                 "Non-irrigated arable land",
                 "Olive groves",
                 "Permanently irrigated land",
                 "Rice fields",
                 "Vineyards",
                 "Discontinuous urban fabric") #to include allotments.

nfi_list <- c(NULL, NA, "Broadleaved") #keep only NULL & NA (i.e. no woodland), and Broadleaved (which could be orchards)

core <- filter(core, corine %in% corine_list) #drop any rows which don't match the corine themes
core <- filter(core, nfi %in% nfi_list) #drop any rows which don't match nfi list

### Create core habitats spatial object and rasterise
message("Rasterising demand source habitats")

core <- core %>%     
  sf::st_buffer(5) %>% 
  sf::st_union() %>% sf::st_as_sf() %>% #Create single sf object
  sf::st_buffer(-5) %>%  # buffer out and in again so that we merge neighbouring patches
  mutate(area_ha = as.numeric(st_area(.))/10000) %>% 
  filter(area_ha > size_threshold) #remove small patches

### Create the source raster (habitats in need of pollination)
pollin_r <- fasterize::fasterize(
  core, # combining edge and core habs
  raster::raster(r) # empty raster, need converting to raster package for fasterize
) %>% 
  terra::rast() %>% 
  terra::classify(cbind(1, 0)) #set value of patches to 0


### Cost distance analysis -----
message("Calculating cost distance")

cost_r <- fasterize::fasterize( #create raster of cell costs
  x,
  raster::raster(r), # empty raster, need converting to raster package for fasterize
  field = "CostPoll" 
) %>% terra::rast()

## cover the cost raster with the source habs
cost_r <- terra::mask(cost_r, pollin_r, inverse=TRUE) %>% # cover ONLY updates NA values, so we need to first remove the source locations from the cost raster
  terra::cover(pollin_r)  # then add the 0 values

costdist_r <- terra::costDist(cost_r, maxiter=100, target = 0, overwrite=TRUE) # do the cost-distance

costdist_clamped <- terra::clamp(costdist_r, upper = dist, value = FALSE) #limit by dist parameter; how far pollinators travel


message("Calculating scores")

# Invert the distance to create scores
scores <- terra::app(costdist_clamped, function(x){(dist - x)/dist})  #range will be 0-1

# Replace NA with 0
scores[is.na(scores)] <- 0


### Clip to study area and save to outputs folder -----

message("Saving final pollination demand map.")

final <- terra::writeRaster(
  terra::mask(scores, terra::vect(studyArea)),
  filename = file.path(save, paste(projectLog$title, runtitle, "pollination_demand.tif", sep="_")),
  overwrite = TRUE  # perhaps not desirable but for now prevents error messages
)


timeB <- Sys.time() # stop time

# write performance to log
projectLog$performance[["dem_pollin"]] <- as.numeric(difftime(
  timeB, timeA, units="mins"
))


updateProjectLog(projectLog) # save revised log

# Delete all the stuff we don't need anymore

on.exit({
  rm(r, pollin_r, costdist_r, costdist_clamped, core)
  cleanUp(scratch)
  message("Pollination demand model finished. Process took ", round(difftime(timeB, timeA, units = "mins"), digits = 1), " minutes. Please check output folder for your maps.")
})


}

