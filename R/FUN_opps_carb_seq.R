##################################################################
### Basic Opportunities Model                                  ###
### 13 Jan 2025                                                ###
### Sandra Angers-Blondin & Rachel Henderson                   ###
##################################################################

#Ben Laverick edit for climate sequestration - 15 May 2025       

#'
#' Basic opportunities model
#'
#' @param x A basemap, in a list of sf tiles or as one sf object. Must have attributes "HabCode_B", "HabBroad", "GI".
#' @param studyArea The boundaries of the site, as one sf object. The final raster will be masked to this shape. For best results this shape should be smaller than the basemap (which should be buffered by typically 300 m - 1km to avoid edge effects).
#' @param ES The name of the ecosystem service being run as a string; this will appear at the end of the file name, followed by "_opps.tif"
#' @param capacity File path for a capacity raster covering the study area
#' @param demand File path for a demand raster covering the study area
#' @param capacity_threshold The maximum capacity value provided by the ecosystem service that is considered 'low capacity'; values above this threshold will not be considered as an opportunity to improve the service
#' @param path_mask A raster file to use as a mask; only opportunities inside the mask will be shown
#' @param demand_threshold The minimum demand value that is considered 'high demand'; values below this threshold will not be considered as an area where the service has demand for improvement
#' @param constraints File path to where constraints are stored
#' @param name_prefix A unique string that will become the first part of the file name
#' @param projectLog The RDS project log file generated by the wizard app and containing all file paths to data inputs and model parameters
#' @param runtitle A customised title you can give a specific model run, which will be appended to your project title in the outputs. If comparing a basemap to an intervention map, we recommend using "pre" and "post", or a short description of the interventions, e.g. "baseline" vs "tree planting".
#' @param save Path to folder where outputs will be saved. By default a folder will be created using your chosen run title, prefixed by "services_". Do not use this argument unless you need to save the outputs somewhere else.
#'
#' @return A raster showing the overlap of capacity and demand
#' @export
#'
#'
carbon_opps_by_threshold <- function(x = parent.frame()$mm,
                              studyArea = parent.frame()$studyArea,
                              ES = NULL,
                              capacity = NULL,
                              demand = NULL,
                              capacity_threshold = NULL,
                              demand_threshold = NULL,
                              constraints = NULL,
                              path_mask = NULL,
                              name_prefix = parent.frame()$name_prefix,
                              projectLog = parent.frame()$projectLog,
                              runtitle = parent.frame()$runtitle,
                              save = NULL) {
  ## Setup ----
  
  timeA <- Sys.time() # start time
  
  
  # Create output directory automatically if doesn't already exist
  if (is.null(save)) {
    save <- file.path(
      projectLog$projpath,
      paste0("opportunities_", runtitle)
    )
    
    if (!dir.exists(save)) {
      dir.create(save)
    }
  } else {
    # if user specified their own save directory we check that it's ok
    if (!dir.exists(save) | file.access(save, 2) != 0) {
      stop("Save directory doesn't exist, or you don't have permission to write to it.")
    }
  }
  
  # Create a temp directory for scratch files
  
  scratch <- file.path(
    projectLog$projpath,
    "ecoservR_scratch"
  )
  
  if (!dir.exists(scratch)) {
    dir.create(scratch)
  }
  
  # if mm is stored in list, combine all before proceeding
  if (isTRUE(class(x) == "list")) {
    x <- do.call(rbind, x) %>% sf::st_as_sf()
    # NOT using rbindlist here because only keeps the extent of the first tile
  }
  
  # Select land use for constraints -----------------------------------------
  
  ## We could add/amend as needed, those are places where you would normally not be able to create a new/different habitat. Mostly
  # infrastructure and private property, also includes water.
  
  # We filter down the mm object
  
  landuse_constraints <- x %>%
    # left_join(ecoservR::hab_lookup[, c("Ph1code", "HabBroad", "HabClass")],
    #   by = c("HabCode_B" = "Ph1code")
    # ) %>% # join habitat desc
    filter(HabBroad %in% c(
      "Built up areas", # keep land uses that are constraints
      "Pavement",
      "Garden",
      "Roads", "Path",
      "Railway",
      "Water, fresh", # to avoid showing aquatic habitats as suitable for interventions!
      "Water, brackish",
      "Intertidal",
      "Saltmarsh", 
      'Swamp',
      'Mire'
    ) | GI %in% c(
      "Playing Field",
      "Other Sports Facility",
      "Bowling Green",
      "Tennis Court",
      "Golf Course",
      "Allotments Or Community Growing Spaces",
      "Private Garden"
    )) %>%
    st_geometry() %>%
    st_as_sf() # drop attributes and make sf df
  
  
  
  
  # Import other constraints ------------------------------------------------
  message("Importing other constraints")
  ## NB: When they're spatial files we can use the wkt filter to reduce amount of data imported
  
  constraints_files <- list.files(constraints,
                                  pattern = paste0(c(".shp$", ".gpkg$", ".gml$"), collapse = "|"),
                                  full.names = TRUE,
                                  recursive = TRUE
  )
  
  # Import power lines
  power_constraints <- st_read(
    constraints_files[grepl("powerlines", constraints_files)],
    wkt_filter = st_as_text(st_as_sfc(st_bbox(studyArea)))
  ) %>% # OSM power lines
    st_geometry() %>%
    st_as_sf() %>%
    st_transform(27700) %>%
    st_make_valid() %>%
    st_buffer(10) %>%
    st_union()
  
  
  # Import HES sites, combine
  heritage_constraints <- rbind(
    
    # monuments
    st_read(
      constraints_files[grepl("monuments", constraints_files)],
      wkt_filter = st_as_text(st_as_sfc(st_bbox(studyArea)))
    ) %>% # OSM power lines
      st_geometry() %>%
      st_as_sf() %>%
      st_transform(27700) %>%
      st_make_valid(),
    
    
    # battlefields
    st_read(
      constraints_files[grepl("battlefield", constraints_files)],
      wkt_filter = st_as_text(st_as_sfc(st_bbox(studyArea)))
    ) %>% # OSM power lines
      st_geometry() %>%
      st_as_sf() %>%
      st_transform(27700)
  ) %>%
    st_buffer(30) %>% # add buffer
    st_union() %>%
    st_make_valid() %>% # union to remove overlaps
    st_geometry() %>%
    st_as_sf() # drop attributes and make sf df
  
  
  # Import ancient woodlands
  ancient_woodland_constraints <- st_read(
    constraints_files[grepl("AWI", constraints_files)],
    wkt_filter = st_as_text(st_as_sfc(st_bbox(studyArea)))
  ) %>% # OSM power lines
    st_geometry() %>%
    st_as_sf() %>%
    st_transform(27700) %>%
    st_make_valid() %>%
    st_buffer(30) %>%
    st_union()
  
  #Import carbon and peatland map 2016
  carbon_constraints <- st_read (
    constraints_files[grepl("CARBON", constraints_files)],
    wkt_filter = st_as_text(st_as_sfc(st_bbox(studyArea)))
  ) %>% 
    filter(IMPORTANCE %in% c(
      "1", # keep land uses that are constraints
      "2",
      "3")) %>%
    st_geometry() %>%
    st_as_sf() %>%
    st_transform(27700) %>%
    st_make_valid() %>%
    st_buffer(10) %>%  #BL do i need the buffer? 
    st_union()
  
  
  

  
  ## we may want other things like
  # peaty locations
  # protected, high-quality habitats (poor quality could actually be an opportunity)
  # ecological/practical suitability constraints like slopes, hydrology, soil type...
  
  
  # Capacity and demand maps
  
  # Capacity and demand maps
  
  if(class(capacity)=="SpatRaster"){
    capacity_map <- capacity
  }else{
    capacity_map <- rast(capacity)
  }
  
  if(class(demand)=="SpatRaster"){
    demand_map <- demand
  }else{
    demand_map <- rast(demand)
  }
  
  # Create raster template --------------------------------------------------
  
  ## using terra
  r <- rast(ext(demand_map), # make sure extent of template is same as extent of constraints by assigning extent of our saved rescaled rasters
            resolution = 10
  )
  terra::crs(r) <- "epsg:27700"
  
  # Rasterise constraints into template --------------------------------------
  
  ## fasterize doesn't yet accept terra so needs to convert template to raster
  
  constraints_all <- fasterize(
    do.call(rbind, list(
      landuse_constraints,
      heritage_constraints,
      power_constraints,
      carbon_constraints
    )) %>%
      st_cast(to = "MULTIPOLYGON", warn = FALSE) %>% st_cast(to = "POLYGON", warn = FALSE), # need to be single-part to work with fasterize
    raster::raster(r)
  )
  
  # Apply constraints to maps -----------------------------------------------
  
  demand_map <- terra::mask(demand_map,
                            terra::rast(constraints_all),
                            inverse = TRUE
  ) # important! We want to EXCLUDE them, not mask our layers to within them
  
  capacity_map <- terra::mask(capacity_map,
                              terra::rast(constraints_all),
                              inverse = TRUE
              
 
  )
  
  
  # Generate opportunities (ES) --------------------------------------------------
  
  ## Threshold demand scores and keep just highest demand
  
  ## NB: Here, to be very correct, we would instead need to calculate the quantiles at NATIONAL level, but you'd never be able to load
  # all the data to calculate quantiles. Even on a chunk, terra will probably tell you that it's using a random sample of the data.
  # We may need to calculate "meta-quantiles" by calculating the quantiles on each chunk separately, then doing an area-weighted mean
  # to get the average 75% percentile for the country based on the 17 data points...
  # If you do that, remember to first apply the subst() line just below to set 0 demand to NA before you calculate.
  
  
  # for demand rasters we reclassify 0 as NA, otherwise very often the desired quantile will be 0!
  # This means we are looking for highest demand ONLY WITHIN AREAS WHERE THERE IS SOME DEMAND.
  
  demand_map <- terra::subst(demand_map, 0, NA)
  
  # calculate quantiles, by layer
  # Qsummary_d <- terra::global(demand_map, terra::quantile, probs = threshold, na.rm = TRUE)
  # names(Qsummary_d) <- "Q"
  
  # Qsummary_c <- terra::global(capacity_map, terra::quantile, probs = 1-threshold, na.rm = TRUE)
  # names(Qsummary_c) <- "Q"
  
  
  # now reclassify each raster using the corresponding relevant quantile
  
  demand_opps <- mapply(
    function(x, q) {
      terra::classify(demand_map[[x]],
                      rcl = matrix(
                        c(
                          -Inf, q, NA,
                          q, Inf, 1
                        ),
                        ncol = 3, byrow = TRUE
                      ),
                      include.lowest = TRUE, right = FALSE
      )
    },
    # x = row.names(Qsummary_d),
    x = 1,
    q = demand_threshold,
    SIMPLIFY = FALSE
  ) %>% terra::rast()
  
  capacity_opps <- mapply(
    function(x, q) {
      terra::classify(capacity_map[[x]],
                      rcl = matrix(
                        c(
                          -Inf, q, 1,
                          q, Inf, NA
                        ),
                        ncol = 3, byrow = TRUE
                      ),
                      include.lowest = TRUE, right = FALSE
      )
    },
    # x = row.names(Qsummary_c),
    x = 1,
    q = capacity_threshold,
    SIMPLIFY = FALSE
  ) %>%
    terra::rast()
  
  
  es_opps <- sum(
    demand_opps, capacity_opps
  )
  
  es_opps <- subst(es_opps, 2, 1)
  
  if(!is.null(path_mask)){
    
    my_mask <- st_crop(st_read(path_mask), studyArea)
    
    my_mask <- rasterize(my_mask, r)
    
    es_opps <- mask(es_opps, my_mask)
  }
  
  
  # Save --------------------------------------------------------------------
  
  terra::writeRaster(es_opps,
                     filename = file.path(save, paste0(name_prefix, "_", ES, "_opps.tif")), overwrite = TRUE
  )
}
