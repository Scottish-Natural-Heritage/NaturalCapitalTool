#############################################
### Access to nature capacity model       ###
### for EcoservR tool                     ###
### Sandra Angers-Blondin                 ###
### 18 Dec 2020                           ###
###                                       ###
### CSJ Update 20 January 2025            ###
###                                       ###
#############################################

#' Access to Nature Capacity Model
#'
#' Runs the access to nature ecosystem service model, generating capacity scores based on perceived "naturalness" 
#' of the habitats and their public accessibility. Calls external datasets which must be supplied by user: 
#' protected areas and core paths.

#' @param x A basemap, in a list of sf tiles or as one sf object. Must have attributes HabCode_B, GI (type of green infrastructure), and GIpublic (Private/Restricted/Public access).
#' @param studyArea The boundaries of the site, as one sf object. The final raster will be masked to this shape. For best results this shape should be smaller than the basemap (which should be buffered by typically 300 m - 1km to avoid edge effects).
#' @param ProtectedAreas sf object containing Protected Areas to include as blue/greenspace. Alternatively, add any additional blue/greenspace polygons here.
#' @param CorePaths sf object containing Core Paths. Alternatively, add any additional path data here.
#' @param PathBuffer radius (m) of buffer around paths, representing the distance path users can still get the benefit from being near nature. Higher values are more relevant in rural areas or for specific landforms, like coastlines.
#' @param res Desired resolution of the raster. Default is 5 m. Range recommended is 5-10m.
#' @param local Radius (m) for focal statistics at local range (maximum distance for effectiveness). Default is 100 m.
#' @param custom_ext A custom extent; the extent of the final output will match this extent
#' @param threshold Size (m2) below which an isolated patch is not considered able to provide the service. Default is 500 m2.
#' @param projectLog The RDS project log file generated by the wizard app and containing all file paths to data inputs and model parameters
#' @param runtitle A customised title you can give a specific model run, which will be appended to your project title in the outputs. If comparing a basemap to an intervention map, we recommend using "pre" and "post", or a short description of the interventions, e.g. "baseline" vs "tree planting".
#' @param save Path to folder where outputs will be saved. By default a folder will be created using your chosen run title, prefixed by "services_". Do not use this argument unless you need to save the outputs somewhere else.
#' @return A raster with raw (arbitrary) capacity scores.
#' @export
#'
#'


capacity_access_scot <- function(x = parent.frame()$mm,
                                 studyArea = parent.frame()$studyArea,
                                 ProtectedAreas,
                                 CorePaths,
                                 PathBuffer = 100,
                                 res = 10,
                                 local = 300,
                                 threshold = 500,
                                 custom_ext = NULL,
                                 projectLog = parent.frame()$projectLog,
                                 runtitle = parent.frame()$runtitle,
                                 save = NULL) {
  timeA <- Sys.time() # start time

  # Create output directory automatically if doesn't already exist
  if (is.null(save)) {
    save <- file.path(
      projectLog$projpath,
      paste0("services_", runtitle)
    )

    if (!dir.exists(save)) {
      dir.create(save)
    }
  } else {
    # if user specified their own save directory we check that it's ok
    if (!dir.exists(save) | file.access(save, 2) != 0) {
      stop("Save directory doesn't exist, or you don't have permission to write to it.")
    }
  }

  # Create a temp directory for scratch files

  scratch <- file.path(
    projectLog$projpath,
    "ecoservR_scratch"
  )

  if (!dir.exists(scratch)) {
    dir.create(scratch)
  }

  studyArea <- sf::st_zm(studyArea, drop = TRUE) # make sure study area doesn't have Z dim


  # if mm is stored in list, combine all before proceeding
  if (isTRUE(class(x) == "list")) {
    message("Recombining basemap tiles")
    x <- do.call(rbind, x) %>% sf::st_as_sf()
    # NOT using rbindlist here because only keeps the extent of the first tile
  }

  x$HabClass <- NULL
  x$HabBroad <- NULL # if the attributes are already present in basemap remove them, as they get joined with lookup

  ### Merge the lookup table -----

  x <- merge(x, hab_lookup, by.x = "HabCode_B", by.y = "Ph1code", all.x = TRUE)

  # removed dependencies on group and GI because intervention maps don't have updated values
  x <- x[c(
    "HabCode_B", "HabClass", "HabBroad", "Make",
    # "Group",
    # "GI",
    "GIpublic", "Naturalness", "Term", "TOID"
  )] # keep only required columns


  ### Create raster template with same properties as mastermap -----

  # r <- raster::raster() # create empty raster
  # raster::crs(r) <- sp::CRS(SRS_string = "EPSG:27700") # hard-coding datum to preserve CRS
  # raster::extent(r) <- raster::extent(x) # set same extent as the shapefile
  # raster::res(r) <- res # set resolution

  r <- raster::raster() # create empty raster
  raster::crs(r) <- sp::CRS(SRS_string = "EPSG:27700") # hard-coding the datum to preserve CRS in QGIS

  if (is.null(custom_ext)) {
    raster::extent(r) <- raster::extent(x)
  } else {
    raster::extent(r) <- raster::extent(custom_ext)
  }

  raster::res(r) <- res # set resolution



  # Buffer the study area so we don't lose anything at the edges

  SAbuffer <- sf::st_buffer(studyArea, local + 100) %>% sf::st_transform(27700)


  ### Also extract paths from basemap
  message("Extracting public pavements and paths from the basemap")

  sidewalk <- dplyr::filter(x, HabCode_B %in% c("J52", "J54")) %>% # pavements are extracted
    sf::st_buffer(PathBuffer) %>% # buffer applied
    sf::st_union() %>% # union to remove overlap
    sf::st_as_sf() # put back in sf format, with only geometry column

  sidewalk <- checkgeometry(sidewalk, "POLYGON")

  # Load CorePaths
  message("Loading CorePaths")
  CorePaths <- CorePaths %>%
    checkcrs(27700) %>%
    sf::st_intersection(SAbuffer) %>%
    sf::st_buffer(PathBuffer) %>% # buffer applied
    # sf::st_union() %>%  # union to remove overlap
    sf::st_as_sf() %>%
    sf::st_cast("POLYGON") # put back in sf format, with only geometry column
  # CorePaths <- checkcrs(CorePaths, 27700)


  CorePaths <- checkgeometry(CorePaths, "POLYGON") %>%
    dplyr::select(x)

  # Join sidewalk and CorePaths
  message("Joining sidewalk & CorePaths")
  # paths <- rbind(sidewalk, CorePaths, shore_path)

  if (nrow(CorePaths) > 0 | nrow(sidewalk) > 0) {
    paths <- rbind(sidewalk, CorePaths)

    message("Extracting all scores from the basemap")
    ### Create the rest of the access objects from basemap

    GI_access <- dplyr::filter(x, GIpublic %in% c("Public")) # keep only publicly accessible greenspaces.
    GI_access <- sf::st_geometry(GI_access) %>% # keep only geometry column
      sf::st_as_sf()
    st_geometry(GI_access) <- "geometry"
    GI_access <- checkgeometry(GI_access, "POLYGON")


    message("Extracting beaches from the basemap")
    ### Create the rest of the access objects from basemap

    foreshore <- x[grep("shore", x$Term), ]
    foreshore <- sf::st_geometry(foreshore) %>% # keep only geometry column
      sf::st_as_sf()

    st_geometry(foreshore) <- "geometry"
    foreshore <- checkgeometry(foreshore, "POLYGON")


    # #Load ProtectedAreas
    # message("Loading ProtectedAreas")
    # ProtectedAreas <- ProtectedAreas %>%
    #   checkcrs(27700) %>%
    #   sf::st_intersection(SAbuffer) %>%
    #   sf::st_union() %>%  # union to remove overlap
    #   sf::st_as_sf()   # put back in sf format, with only geometry column
    #
    # st_geometry(ProtectedAreas) <- "geometry"
    # #checkcrs(ProtectedAreas, 27700)
    #
    # ProtectedAreas <- checkgeometry(ProtectedAreas, "POLYGON") %>%
    #   dplyr::select(geometry)
    #
    #

    # Join GI_access and foreshore


    natural_habs <- dplyr::filter(x, Make %in% c("Natural")) # keep only publicly accessible greenspaces.
    natural_habs <- sf::st_geometry(natural_habs) %>% # keep only geometry column
      sf::st_as_sf()
    st_geometry(natural_habs) <- "geometry"
    natural_habs <- checkgeometry(natural_habs, "POLYGON")

    message("Joining GI_access & foreshore")
    nature <- rbind(natural_habs, GI_access, foreshore)
    nature <- unique(nature)

    ### Rasterize -----

    ### Mask nature by paths
    message("Masking nature by paths")

    # Rasterize the access mask for much faster processing
    pathsmask_r <- raster::writeRaster(
      fasterize::fasterize(paths, r, field = NULL, background = NA),
      filename = file.path(scratch, "all_access"),
      overwrite = TRUE # because it's a temporary file we don't mind overwriting it if it exists
    )

    rm(paths)

    # Rasterize nature

    nature_r <- raster::writeRaster(
      fasterize::fasterize(nature, r, field = NULL, background = NA),
      filename = file.path(scratch, "all_nature"),
      overwrite = TRUE # because it's a temporary file we don't mind overwriting it if it exists
    )

    # crs shifted a tiny fraction during a previous step so resetting:
    raster::crs(pathsmask_r) <- raster::crs(nature_r)

    access_r <- raster::writeRaster(
      raster::mask(nature_r, pathsmask_r), # mask all greenspace by access layer
      filename = file.path(scratch, "accessible_nature"),
      overwrite = TRUE # because it's a temporary file we don't mind overwriting it if it exists
    )

    # Rasterize the greenspace on Naturalness
    green_all <- dplyr::filter(
      x,
      !HabBroad %in% c(
        "Artificial exposure / waste",
        "Built up areas",
        "Roads", "Railway", "Pavement", "Path"
      ),
      !HabCode_B %in% c(
        "Unclassified, not greenspace",
        "Unclassified, area in development"
      )
    )


    naturalness_scores_r <- raster::writeRaster(
      fasterize::fasterize(green_all, r, field = "Naturalness", background = NA),
      filename = file.path(scratch, "studyarea_scores"),
      overwrite = TRUE # because it's a temporary file we don't mind overwriting it if it exists
    )

    rm(green_all, nature_r, pathsmask_r)

    ### Mask all scores by areas of accessible nature
    message("Getting naturalness scores within accessible nature areas")
    access_scores_r <- raster::writeRaster(
      raster::mask(naturalness_scores_r, access_r), # mask all greenspace by access layer
      filename = file.path(scratch, "accessible_nature_scores"),
      overwrite = TRUE # because it's a temporary file we don't mind overwriting it if it exists
    )

    ### Extract threshold -----

    # Extract by mask is used to create a dataset above a user-defined threshold of greenspace sites
    # skipped this one - functional threshold is applied later


    ### Multiply raster by 10 to get scores ----

    score_access_r <- raster::writeRaster(
      access_r * 10,
      filename = file.path(scratch, "accessnature_accessgreen"),
      overwrite = TRUE
    )


    rm(naturalness_scores_r, access_r)

    # crop scores to study area plus buffer - RH edit, no need to crop here as layers are already at the right
    # extent by the time they get to this point
    # message("Cropping scores raster to study area before focal statistics...")
    # score_access_r2 <- raster::crop(score_access_r, SAbuffer)

    ### Focal statistics ----

    message("Calculating scores")

    score_access_r <- focalScore(score_access_r, radius = local, type = "sum")


    ### Create functional threshold mask ----
    message("Applying functional threshold mask")

    # This function will create a mask raster based on patch statistics, removing all patches smaller than the threshold.

    # Accessible greenspace raster
    score_access_r <- writeRaster(
      functionalMask(score_access_r, # the score raster we apply the function to
        local = local, # the local search radius set previously
        res = res, # the resolution of the raster set previously
        proportion = 0.05, # proportion of cells in the search circle which can have a score of 10 without being considered to contribute to the service
        threshold = threshold
      ) # the size threshold set previously
      ,
      filename = file.path(scratch, "accessnature_accessscore.tif"),
      overwrite = TRUE
    )
  } else {
    score_access_r <- r
  }

  final_access <- writeRaster(
    mask(score_access_r, studyArea),
    filename = file.path(save, paste(projectLog$title, runtitle, "access_nature_accessOnly_capacity.tif", sep = "_")),
    overwrite = TRUE
  )


  timeB <- Sys.time() # stop time

  # write performance to log
  projectLog$performance[["cap_access"]] <- as.numeric(difftime(
    timeB, timeA,
    units = "mins"
  ))


  updateProjectLog(projectLog) # save revised log



  # Delete all the stuff we don't need anymore

  on.exit({
    rm(r, final_access)
    cleanUp(scratch)
    message("Access to nature capacity model finished. Process took ", round(difftime(timeB, timeA, units = "mins"), digits = 1), " minutes. Please check output folder for your maps.")
  })

  return({
    ## returns the objects in the global environment
    invisible({
      projectLog <<- projectLog
    })
  })
}

